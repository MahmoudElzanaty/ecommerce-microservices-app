"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const socket_io_1 = require("socket.io");
const socket_io_client_1 = require("socket.io-client");
const redis_adapter_1 = require("@socket.io/redis-adapter");
const redis_1 = require("redis");
const out_1 = require("./utils/out");
const general_1 = require("./utils/general");
const socket_1 = require("./utils/socket");
const health_1 = require("./utils/health");
/**
 *
 * @typedef {object} SetupParams
 * @property {http.Server} object.httpServer - Express server. Only needed if socket server is not passed to
 * the function.
 * @property {number} httpPort - Port where the socket client will be listening
 * @property {io.Server | undefined} socketServer - If passed, this will be the socket server used to
 * set up the connection
 * @property {number} redisPort - Port where the redis server is running. Default to 6379.
 * @property {string} socketPath - Path where the socket server should run on. Only needed if no socket
 * server is passed to the function.
 * @property {string} redisHost - IP on which the redis server is running
 * @property {string} clientName - Application name using this package. Needed for log files.
 * @property {function} connectFn - Function which will be executed on the **on connection**
 * callback of the socket server.
 */
/**
 *
 * @param {SetupParams} params
 */
const setup = async ({ httpServer, expressApp, httpPort, socketServer, redisPort = 6379, socketPath = '/ws', redisHost, clientName, connectFn, healthEndpoint, key, logLevel, }) => {
    (0, general_1.setName)(clientName);
    out_1.default.defaultMeta = { clientName };
    if (logLevel) {
        out_1.default.info(`Setting log level to ${logLevel}`);
        out_1.default.level = logLevel;
    }
    const logger = out_1.default.child({ function: 'setup' });
    logger.info(`Setting up socket: ${clientName}`);
    if (!socketServer && (!httpServer || !socketPath)) {
        throw new Error('No socket server or server info received to initialize redis socket');
    }
    if (expressApp) {
        logger.info(`Setting health check`);
        expressApp.use(healthEndpoint || '/health', health_1.healthCheck);
    }
    const options = {
        path: socketPath,
        transports: ['websocket'],
        allowUpgrades: false,
    };
    let server = socketServer;
    if (!server) {
        if (!httpServer) {
            throw new Error('No socket server or server info received to initialize redis socket');
        }
        server = new socket_io_1.Server(httpServer, options);
    }
    const password = process.env.REDIS_PASSWORD;
    const pubClient = (0, redis_1.createClient)({
        url: `${redisHost.indexOf('redis://') === 0 ? '' : 'redis://'}${redisHost}:${redisPort}`,
        password: password || undefined,
    });
    const subClient = pubClient.duplicate();
    pubClient.on('error', (err) => {
        logger.error(`Redis:: Error on pubClient: ${err.message}`, err);
    });
    subClient.on('error', (err) => {
        logger.error(`Redis:: Error on subClient: ${err.message}`, err);
    });
    await Promise.all([pubClient.connect(), subClient.connect()]);
    server.adapter((0, redis_adapter_1.createAdapter)(pubClient, subClient, { key, requestsTimeout: 60000 }));
    server.of('/').adapter.on('error', (err) => {
        logger.error(`Redis-Adapter:: Error: ${err.message}`, err);
    });
    // Emit healthCheck every 2 mins
    (0, health_1.initAliveInterval)();
    (0, health_1.emitInTime)(server);
    server.on('connection', (socket) => {
        socket.on('error', (error) => {
            logger.error(`Socket error on server connection: ${error.message}`, error);
        });
        if (connectFn) {
            connectFn(socket);
        }
        logger.debug(`Connected ${socket.id}`);
        socket.on('disconnect', () => {
            logger.debug(`Socket disconnected: ${socket.id}`);
        });
        socket.on('localClient', () => {
            logger.info(`Joining local client to room ${socket_1.paymentRoomId}`);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            socket.join(socket_1.paymentRoomId);
        });
    });
    // Store the server in a variable
    (0, socket_1.setServer)(server);
    logger.info('Going to create socket client');
    const client = (0, socket_io_client_1.io)(`http://localhost:${httpPort}`, {
        autoConnect: true,
        path: options.path,
        secure: true,
        transports: ['websocket'],
        upgrade: false,
    });
    client.on('error', (err) => {
        logger.error(`Error on client socket: ${err.message}`, err);
    });
    client.on('connect_error', (err) => {
        logger.error(`Client connect_error: ${err.message}`, err);
    });
    client.on('connect_timeout', () => {
        logger.error('Socket client connect timeout');
    });
    client.on('healthCheck', () => {
        (0, health_1.onAlive)();
    });
    client.on('reconnect_attempt', () => {
        logger.info(`Socket client trying to reconnect`);
        // client.io.opts.transports = ['polling', 'websocket'];
    });
    (0, socket_1.setClient)(client);
    client.emit('localClient');
    return server;
};
exports.default = setup;
//# sourceMappingURL=index.js.map