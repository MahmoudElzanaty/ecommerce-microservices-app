"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeToRoom = exports.getClient = exports.setClient = exports.getServer = exports.setServer = exports.paymentRoomId = void 0;
const crypto_1 = require("crypto");
const os_1 = require("os");
const out_1 = require("./out");
const PAYMENT_SERVER_TIMEOUT = parseInt(process.env.PAYMENT_SERVER_TIMEOUT || '30', 10); // seconds
const DEFAULT_ROOM_NAME = 'default';
const SEARCH_FUNCTION = 'get_server';
let currentServer;
let currentClient;
exports.paymentRoomId = (0, os_1.hostname)();
const setServer = (server) => {
    currentServer = server;
};
exports.setServer = setServer;
const getServer = () => currentServer;
exports.getServer = getServer;
const setClient = (client) => {
    currentClient = client;
};
exports.setClient = setClient;
const getClient = () => currentClient;
exports.getClient = getClient;
const generateId = () => (0, crypto_1.randomUUID)();
const getAvailableRoom = async (serviceName) => new Promise((resolve, reject) => {
    const id = generateId();
    const logger = out_1.default.child({ function: 'getAvailableRoom', commandId: id, serviceName });
    const timeout = setTimeout(() => {
        logger.error(`[getAvailableRoom]::Timeout (${PAYMENT_SERVER_TIMEOUT}) reached (${id}).`);
        reject(new Error(`[getAvailableRoom]::Timeout (${PAYMENT_SERVER_TIMEOUT}) reached (${id}).`));
    }, PAYMENT_SERVER_TIMEOUT * 1000);
    logger.info(`Gonna ask for available service with name ${serviceName} and id ${id}`);
    if (!currentClient || !currentServer) {
        logger.error(`[getAvailableRoom]::No socket ${currentClient ? 'server' : 'client'} available`);
        clearTimeout(timeout);
        reject(new Error(`[getAvailableRoom]::No socket ${currentClient ? 'server' : 'client'} available`));
    }
    else {
        currentClient.once(id, (data) => {
            clearTimeout(timeout);
            if (data.ok) {
                logger.info(`[getAvailableRoom]::Received available service: ${data.d.id}`);
                resolve(data.d.id);
            }
            else {
                logger.error(`[getAvailableRoom]::Error: ${data.e || 'unknown'}`, {
                    error: data.e,
                    stack: data.stack,
                });
                reject(new Error(`[getAvailableRoom]::Error: ${data.e || 'unknown'}`));
            }
        });
        currentServer.to(serviceName).emit(SEARCH_FUNCTION, id, exports.paymentRoomId);
    }
});
const executeToRoom = async (name, params, microName) => {
    let logger = out_1.default.child({ function: 'executeToRoom', microName, commandName: name, params });
    if (!microName) {
        logger.warn('No micro name provided, looking for socket in **default** room');
    }
    const room = await getAvailableRoom(microName || DEFAULT_ROOM_NAME);
    logger = logger.child({ room });
    logger.info(`[executeToRoom]::Got room ${room}`);
    return new Promise((resolve, reject) => {
        if (currentClient && currentServer && room) {
            const destinationRoomSocket = currentServer.to(room);
            const id = generateId();
            logger = logger.child({ commandId: id, currentClient: currentClient.id });
            logger.info(`[executeToRoom]:: emit ${name} to room ${room} with id: ${id} and micro name ${microName || DEFAULT_ROOM_NAME} from: ${currentClient.id}`);
            currentClient.once(id, (res) => {
                logger.info(`[executeToRoom]:: receive ${name} from room ${room}`);
                if (res.ok) {
                    resolve(res.d);
                }
                else {
                    const error = new Error(res.e);
                    error.stack = res.stack;
                    reject(error);
                }
            });
            if (params) {
                destinationRoomSocket.emit(name, id, exports.paymentRoomId, params);
            }
            else {
                destinationRoomSocket.emit(name, id, exports.paymentRoomId);
            }
        }
        else {
            logger.error(`[executeToRoom]::No socket found with name: ${microName || DEFAULT_ROOM_NAME}`);
            reject(new Error(`[executeToRoom]::No socket found with name: ${microName || DEFAULT_ROOM_NAME}`));
        }
    });
};
exports.executeToRoom = executeToRoom;
//# sourceMappingURL=socket.js.map